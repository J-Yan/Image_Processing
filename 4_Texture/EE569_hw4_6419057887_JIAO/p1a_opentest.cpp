// Name: Yan Jiao
// USC ID: 6419057887
// USC Email: yanjiao@usc.edu

#include "stdafx.h"
#include<opencv2\core.hpp>
#include<opencv2\highgui.hpp>


#include <stdio.h>
#include <iostream>
#include <stdlib.h>
#include <vector>
#include <math.h>
#include <string>

using namespace cv;
using namespace std;


vector<vector<unsigned char>> pad(vector<vector<unsigned char>> ori, int s, int padNum) {
	vector<vector<unsigned char>> after(s+4,vector<unsigned char>(s+4));
	for (int i = 0; i < s; i++) {
		
			for (int ii = 0; ii < s; ii++) {
				for (int jj = 0; jj < s; jj++) {
					after[ii + 2][jj + 2] = ori[ii][jj];
				}
			}

			for (int j = 0; j < padNum; j++) {
				for (int m = 0; m < s; m++) {
					after[j][m + 2] = ori[padNum - j][m];
					after[s - 1 - j + 4][m + 2] = ori[s - 1 - padNum + j][m];
				}
			}
			for (int jj = 0; jj < padNum; jj++) {
				for (int m = 0; m < s+4; m++) {
					after[m][jj] = after[m][2 * padNum - jj];
					after[m][s + 4 - 1 - jj] = after[m][s + 4 - 1 - 2 * padNum + jj];
				}
			}
		
	}
	return after;
}

vector<vector<double>> histogram_equalization(vector<vector<unsigned char>> img, int s) {
	vector<vector<double>> new_img(s, vector<double>(s));
	vector<vector<int>> new_order(256);
	for (int i = 0; i<s; i++) {
		for (int j = 0; j<s; j++) {
			double k = img[i][j];
			if (k >= 0 && k <= 255) {
				new_order[k].push_back(i*s + j);
			}
		}
	}
	double prob[256];
	double result[256];
	for (int i = 0; i<256; i++) {
		prob[i] = (double)new_order[i].size() / pow(s, 2);
	}
	result[0] = prob[0] * 255;
	for (int i = 1; i<256; i++) {
		prob[i] += prob[i - 1];
		result[i] = prob[i] * 255;
	}
	for (int i = 0; i<s; i++) {
		for (int j = 0; j<s; j++) {
			new_img[i][j] = result[(int)img[i][j]];
		}
	}
	
	return new_img;
}


int main(int argc, char *argv[])
{
	// 1D Kernel for 5*5 Laws Filters
	int Kernel[5][5] = {
		{ 1, 4, 6, 4, 1 },
		{ -1, -2, 0, 2, 1 },
		{ -1, 0, 2, 0, -1 },
		{ -1, 2, 0, -2, 1 },
		{ 1, -4, 6, -4, 1 },
	};
	// Define file pointer and variables
	FILE *file;
	const int BytesPerPixel = 1;
	const int Size = 128;
	const int NumF = 25;

	// Check for proper syntax
	if (argc < 3) {
		cout << "Syntax Error - Incorrect Parameter Usage:" << endl;
		cout << "program_name input_image.raw output_image.raw [BytesPerPixel = 1] [Size = 256]" << endl;
		return 0;
	}

	// Check if image is grayscale or color
	if (argc < 4) {
		//BytesPerPixel = 1; // default is grey image
	}

	// Allocate image data array
	unsigned char ImageMat[12][Size+4][Size+4];
	unsigned char ImageMattemp[12][Size][Size][BytesPerPixel];
	// Read image (filename specified by first argument) into image data matrix
	for (int i = 0; i < 12; i++) {
		if (!(file = fopen(argv[i + 1], "rb"))) {
			cout << "Cannot open file: " << argv[i + 1] << endl;
			exit(1);
		}
		fread(ImageMattemp[i], sizeof(unsigned char), Size*Size*BytesPerPixel, file);
		fclose(file);
	}

	vector<vector<vector<unsigned char>>> imagePadIn(12, vector<vector<unsigned char>>(Size + 4, vector<unsigned char>(Size + 4)));
	vector<vector<vector<unsigned char>>> imagePadOut(12, vector<vector<unsigned char>>(Size + 4, vector<unsigned char>(Size + 4)));
	for (int m = 0; m < 12; m++) {
		for (int i = 0; i < Size; i++) {
			for (int j = 0; j < Size; j++) {
				imagePadIn[m][i][j] = ImageMattemp[m][i][j][0];
			}
		}
	}

	for (int m = 0; m < 12; m++) {
		imagePadOut[m] = pad(imagePadIn[m],Size,2);
	}

	
	///////////////////////// INSERT YOUR PROCESSING CODE HERE /////////////////////////


	// subtract image mean
	double Mean[12];
	double ImageMatD[12][Size][Size];
	vector<vector<vector<double>>> imageAfterMean(12, vector<vector<double>>(Size + 4, vector<double>(Size + 4)));
	
	for (int i = 0; i < 12; i++) {
		imageAfterMean[i] = histogram_equalization(imagePadOut[i], Size + 4);
	}
	
	/*for (int i = 0; i < 12; i++) {
		double a = 0;
		for (int ii = 0; ii < Size; ii++) {
			for (int jj = 0; jj < Size; jj++) {
				a += imagePadOut[i][ii][jj];
			}
		}
		Mean[i] = a / pow(Size+4, 2);
		for (int ii = 0; ii < Size; ii++) {
			for (int jj = 0; jj < Size; jj++) {
				imageAfterMean[i][ii][jj] = imagePadOut[i][ii][jj] - Mean[i];
			}
		}
	}*/

	// total 25 filters
	int FilterIndex = 0;
	int Laws[25][5][5];
	for (int i = 0; i < 5; i++) {
		for (int j = 0; j < 5; j++) {
			for (int m = 0; m < 5; m++) {
				for (int n = 0; n < 5; n++) {
					Laws[FilterIndex][m][n] = Kernel[i][m] * Kernel[j][n];
				}
			}
			FilterIndex++;
		}
	}

	//int Filtered[12][NumF][Size][128];

	cout << "*";

	// for each image, filter 25 times

	// average energy
	double AverEnergy[12][25];
	for (int i = 0; i < 12; i++) {
		for (int j = 0; j < 25; j++) {
			// cout<<"*";
			double Aver = 0;
			for (int ii = 2; ii < Size + 1; ii++) {
				for (int jj = 2; jj < Size + 1; jj++) {
					double temp = 0;
					for (int fi = -2; fi < 3; fi++) {
						for (int fj = -2; fj < 3; fj++) {
							temp += imageAfterMean[i][ii + fi][jj + fj] * Laws[j][2 + fi][2 + fj];
						}
					}
					Aver += pow(temp, 2);
				}
			}
			AverEnergy[i][j] = Aver / pow(Size, 2);
		}
	}

	// 25D to 15D
	for (int i = 0; i < 12; i++) {
		AverEnergy[i][5] = (AverEnergy[i][1] + AverEnergy[i][5]) / 2;
		AverEnergy[i][1] = AverEnergy[i][5];
		AverEnergy[i][10] = (AverEnergy[i][10] + AverEnergy[i][2]) / 2;
		AverEnergy[i][2] = AverEnergy[i][10];
		AverEnergy[i][11] = (AverEnergy[i][11] + AverEnergy[i][7]) / 2;
		AverEnergy[i][7] = AverEnergy[i][11];
		AverEnergy[i][15] = (AverEnergy[i][15] + AverEnergy[i][3]) / 2;
		AverEnergy[i][3] = AverEnergy[i][15];
		AverEnergy[i][16] = (AverEnergy[i][16] + AverEnergy[i][8]) / 2;
		AverEnergy[i][8] = AverEnergy[i][16];
		AverEnergy[i][20] = (AverEnergy[i][20] + AverEnergy[i][4]) / 2;
		AverEnergy[i][4] = AverEnergy[i][20];
		AverEnergy[i][21] = (AverEnergy[i][21] + AverEnergy[i][9]) / 2;
		AverEnergy[i][9] = AverEnergy[i][21];
		AverEnergy[i][17] = (AverEnergy[i][17] + AverEnergy[i][13]) / 2;
		AverEnergy[i][13] = AverEnergy[i][17];
		AverEnergy[i][22] = (AverEnergy[i][22] + AverEnergy[i][14]) / 2;
		AverEnergy[i][14] = AverEnergy[i][22];
		AverEnergy[i][23] = (AverEnergy[i][19] + AverEnergy[i][23]) / 2;
		AverEnergy[i][19] = AverEnergy[i][23];
	}


	// // average energy
	// double AverEnergy[12][25];
	// for (int i = 0; i < 12; i++) {
	//   for (int j = 0; j < 25; j++) {
	//     int temp = 0;
	//
	//     AverEnergy[i][j] = temp/124/124;
	//   }
	// }

	
	// normalization of anergy
	double amean[1][25] = {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0};
	for (int i = 0; i < 12; i++) {
		for (int j = 0; j < 25; j++) {
			amean[0][j] += AverEnergy[i][j];
		}
	}
	for (int j = 0; j < 25; j++) {
		amean[0][j] = amean[0][j]/12;
	}
	// standard deviation
	double standDev[1][25] = { 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 };
	for (int i = 0; i < 12; i++) {
		for (int j = 0; j < 25; j++) {
			standDev[0][j] += pow(AverEnergy[i][j] - amean[0][j], 2);
		}
	}
	for (int j = 0; j < 25; j++) {
		standDev[0][j] = sqrt(standDev[0][j]/12);
	}

	// normalize
	for (int i = 0; i < 12; i++) {
		for (int j = 0; j < 25; j++) {
			AverEnergy[i][j] = (AverEnergy[i][j] - amean[0][j])/standDev[0][j];
		}
	}

	for (int i = 0; i < 12; i++) {
		for (int j = 0; j < 25; j++) {
			cout << AverEnergy[i][j] << " ";
		}
		cout << endl;
	}
	for (int j = 0; j < 25; j++) {
		cout << standDev[0][j] << " ";
		cout << endl;
		cout << amean[0][j] << " ";
	}

	Mat data_pts(12, 25, CV_32F);
	for (int i = 0; i < 12; i++) {
		for (int j = 0; j < 25; j++) {
			data_pts.at<float>(i, j) = AverEnergy[i][j];
		}
	}

	PCA pca(data_pts, Mat(), PCA::DATA_AS_ROW, 3);
	Mat threeD;
	pca.project(data_pts, threeD);

	cout << "3D" << endl << threeD;

	TermCriteria criteria = TermCriteria(CV_TERMCRIT_EPS + CV_TERMCRIT_ITER, 40, 0.001);
	int k = 4;
	int numberOfAttempts = 3;
	Mat labels, centers;

	// // // Apply K means:
	kmeans(threeD, k, labels, criteria, numberOfAttempts, KMEANS_PP_CENTERS, centers);

	cout << "labels:   " << endl << labels;

	// for (int i = 0; i < 5; i++) {
	//   for (int j = 0; j < 5; j++) {
	//       cout<<Laws[0][i][j]<<" ";
	//   }
	//   cout<<endl;
	// }


	

unsigned char test[Size + 4][Size + 4][1];
for (int i = 0; i < Size+4; i++) {
	   for (int j = 0; j < Size+4; j++) {
		   test[i][j][0] = imagePadOut[0][i][j];
	   }
	   
	 }

	// Write image data (filename specified by second argument) from image data matrix

	if (!(file = fopen(argv[13], "wb"))) {
		cout << "Cannot open file: " << argv[13] << endl;
		exit(1);
	}
	fwrite(test, sizeof(unsigned char), (Size+4)*(Size+4)*BytesPerPixel, file);
	fclose(file);

	// hold the command window
	string exitflag("\n");
	cout << "Try New Quit Processing. Start Test..." << endl;
	cout << "Press Q or q key to quit..." << endl;
	getline(cin, exitflag);
	while (exitflag.find('q') == string::npos && exitflag.find('Q') == string::npos)
	{
		cout << "Press Q or q key to quit..." << endl;
		getline(cin, exitflag);
	}


	return 0;
}


/*
/////////////////////////////////////////////test2=========================

int main(int argc, char *argv[])
{
// 1D Kernel for 5*5 Laws Filters
int Kernel[3][5] = {

{ -1, -2, 0, 2, 1 },
{ -1, 0, 2, 0, -1 },
{ -1, 2, 0, -2, 1 }

};
// Define file pointer and variables
FILE *file;
const int BytesPerPixel = 1;
const int Size = 128;
const int NumF = 9;

// Check for proper syntax
if (argc < 3) {
cout << "Syntax Error - Incorrect Parameter Usage:" << endl;
cout << "program_name input_image.raw output_image.raw [BytesPerPixel = 1] [Size = 256]" << endl;
return 0;
}

// Check if image is grayscale or color
if (argc < 4) {
//BytesPerPixel = 1; // default is grey image
}

// Allocate image data array
unsigned char ImageMat[12][Size+4][Size+4];
unsigned char ImageMattemp[12][Size][Size][BytesPerPixel];
// Read image (filename specified by first argument) into image data matrix
for (int i = 0; i < 12; i++) {
if (!(file = fopen(argv[i + 1], "rb"))) {
cout << "Cannot open file: " << argv[i + 1] << endl;
exit(1);
}
fread(ImageMattemp[i], sizeof(unsigned char), Size*Size*BytesPerPixel, file);
fclose(file);
}

vector<vector<vector<unsigned char>>> imagePadIn(12, vector<vector<unsigned char>>(Size + 4, vector<unsigned char>(Size + 4)));
vector<vector<vector<unsigned char>>> imagePadOut(12, vector<vector<unsigned char>>(Size + 4, vector<unsigned char>(Size + 4)));
for (int m = 0; m < 12; m++) {
for (int i = 0; i < Size; i++) {
for (int j = 0; j < Size; j++) {
imagePadIn[m][i][j] = ImageMattemp[m][i][j][0];
}
}
}

for (int m = 0; m < 12; m++) {
imagePadOut[m] = pad(imagePadIn[m],Size,2);
}


///////////////////////// INSERT YOUR PROCESSING CODE HERE /////////////////////////


// subtract image mean
double Mean[12];
double ImageMatD[12][Size][Size];
vector<vector<vector<double>>> imageAfterMean(12, vector<vector<double>>(Size + 4, vector<double>(Size + 4)));
for (int i = 0; i < 12; i++) {
double a = 0;
for (int ii = 0; ii < Size; ii++) {
for (int jj = 0; jj < Size; jj++) {
	a += imagePadOut[i][ii][jj];
}
}
Mean[i] = a / pow(Size+4, 2);
for (int ii = 0; ii < Size; ii++) {
for (int jj = 0; jj < Size; jj++) {
imageAfterMean[i][ii][jj] = imagePadOut[i][ii][jj] - Mean[i];
}
}
}
// total 9 filters
int FilterIndex = 0;
int Laws[9][5][5];
for (int i = 0; i < 3; i++) {
for (int j = 0; j < 3; j++) {
for (int m = 0; m < 5; m++) {
for (int n = 0; n < 5; n++) {
Laws[FilterIndex][m][n] = Kernel[i][m] * Kernel[j][n];
}
}
FilterIndex++;
}
}

//int Filtered[12][NumF][Size][128];

cout << "*";

// for each image, filter 25 times

// average energy
double AverEnergy[12][9];
for (int i = 0; i < 12; i++) {
for (int j = 0; j < 9; j++) {
// cout<<"*";
double Aver = 0;
for (int ii = 2; ii < Size + 1; ii++) {
for (int jj = 2; jj < Size + 1; jj++) {
double temp = 0;
for (int fi = -2; fi < 3; fi++) {
for (int fj = -2; fj < 3; fj++) {
temp += imageAfterMean[i][ii + fi][jj + fj] * Laws[j][2 + fi][2 + fj];
}
}
Aver += pow(temp, 2);
}
}
AverEnergy[i][j] = Aver / pow(Size, 2);
}
}

// // average energy
// double AverEnergy[12][25];
// for (int i = 0; i < 12; i++) {
//   for (int j = 0; j < 25; j++) {
//     int temp = 0;
//
//     AverEnergy[i][j] = temp/124/124;
//   }
// }


// normalization of anergy
double amean[1][9] = {0,0,0,0,0,0,0,0,0};
for (int i = 0; i < 12; i++) {
for (int j = 0; j < 9; j++) {
amean[0][j] += AverEnergy[i][j];
}
}
for (int j = 0; j < 9; j++) {
amean[0][j] = amean[0][j]/12;
}
// standard deviation
double standDev[1][9] = { 0,0,0,0,0,0,0,0,0};
for (int i = 0; i < 12; i++) {
for (int j = 0; j < 9; j++) {
standDev[0][j] += pow(AverEnergy[i][j] - amean[0][j], 2);
}
}
for (int j = 0; j < 9; j++) {
standDev[0][j] = sqrt(standDev[0][j]/12);
}

// normalize
for (int i = 0; i < 12; i++) {
for (int j = 0; j < 9; j++) {
AverEnergy[i][j] = (AverEnergy[i][j] - amean[0][j])/standDev[0][j];
}
}

for (int i = 0; i < 12; i++) {
for (int j = 0; j < 9; j++) {
cout << AverEnergy[i][j] << " ";
}
cout << endl;
}
for (int j = 0; j < 9; j++) {
cout << standDev[0][j] << " ";
cout << endl;
cout << amean[0][j] << " ";
}

Mat data_pts(12, 9, CV_32F);
for (int i = 0; i < 12; i++) {
for (int j = 0; j < 9; j++) {
data_pts.at<float>(i, j) = AverEnergy[i][j];
}
}

PCA pca(data_pts, Mat(), PCA::DATA_AS_ROW, 3);
Mat threeD;
pca.project(data_pts, threeD);

cout << "3D" << endl << threeD;

TermCriteria criteria = TermCriteria(CV_TERMCRIT_EPS + CV_TERMCRIT_ITER, 40, 0.001);
int k = 4;
int numberOfAttempts = 3;
Mat labels, centers;

// // // Apply K means:
kmeans(threeD, k, labels, criteria, numberOfAttempts, KMEANS_PP_CENTERS, centers);

cout << "labels:   " << endl << labels;

// for (int i = 0; i < 5; i++) {
//   for (int j = 0; j < 5; j++) {
//       cout<<Laws[0][i][j]<<" ";
//   }
//   cout<<endl;
// }




unsigned char test[Size + 4][Size + 4][1];
for (int i = 0; i < Size+4; i++) {
for (int j = 0; j < Size+4; j++) {
test[i][j][0] = imagePadOut[0][i][j];
}

}

// Write image data (filename specified by second argument) from image data matrix

if (!(file = fopen(argv[13], "wb"))) {
cout << "Cannot open file: " << argv[13] << endl;
exit(1);
}
fwrite(test, sizeof(unsigned char), (Size+4)*(Size+4)*BytesPerPixel, file);
fclose(file);

// hold the command window
string exitflag("\n");
cout << "Try New Quit Processing. Start Test..." << endl;
cout << "Press Q or q key to quit..." << endl;
getline(cin, exitflag);
while (exitflag.find('q') == string::npos && exitflag.find('Q') == string::npos)
{
cout << "Press Q or q key to quit..." << endl;
getline(cin, exitflag);
}


return 0;
}


///////////////////////////////====================================
*/


/*
//////////////////////////////////////// T E S T  1//////////////////////////////////////////////////



int main(int argc, char *argv[])
{
	// 1D Kernel for 5*5 Laws Filters
	//int Kernel[5][5] = {
	//	{ 1, 4, 6, 4, 1 },
	//	{ -1, -2, 0, 2, 1 },
	//	{ -1, 0, 2, 0, -1 },
	//	{ -1, 2, 0, -2, 1 },
	//	{ 1, -4, 6, -4, 1 },
	//};
	int Kernel[3][5] = {
		
		{ -1, -2, 0, 2, 1 },
		{ -1, 0, 2, 0, -1 },
		{ -1, 2, 0, -2, 1 }
		
	};
	// Define file pointer and variables
	FILE *file;
	const int BytesPerPixel = 1;
	const int Size = 128;
	const int NumF = 9;

	// Check for proper syntax
	if (argc < 3) {
		cout << "Syntax Error - Incorrect Parameter Usage:" << endl;
		cout << "program_name input_image.raw output_image.raw [BytesPerPixel = 1] [Size = 256]" << endl;
		return 0;
	}

	// Check if image is grayscale or color
	if (argc < 4) {
		//BytesPerPixel = 1; // default is grey image
	}

	// Allocate image data array
	unsigned char ImageMat[12][Size + 4][Size + 4];
	unsigned char ImageMattemp[12][Size][Size][BytesPerPixel];
	// Read image (filename specified by first argument) into image data matrix
	for (int i = 0; i < 12; i++) {
		if (!(file = fopen(argv[i + 1], "rb"))) {
			cout << "Cannot open file: " << argv[i + 1] << endl;
			exit(1);
		}
		fread(ImageMattemp[i], sizeof(unsigned char), Size*Size*BytesPerPixel, file);
		fclose(file);
	}

	vector<vector<vector<unsigned char>>> imagePadIn(12, vector<vector<unsigned char>>(Size + 4, vector<unsigned char>(Size + 4)));
	vector<vector<vector<unsigned char>>> imagePadOut(12, vector<vector<unsigned char>>(Size + 4, vector<unsigned char>(Size + 4)));
	for (int m = 0; m < 12; m++) {
		for (int i = 0; i < Size; i++) {
			for (int j = 0; j < Size; j++) {
				imagePadIn[m][i][j] = ImageMattemp[m][i][j][0];
			}
		}
	}

	for (int m = 0; m < 12; m++) {
		imagePadOut[m] = pad(imagePadIn[m], Size, 2);
	}


	///////////////////////// INSERT YOUR PROCESSING CODE HERE /////////////////////////


	// subtract image mean
	double Mean[12];
	double ImageMatD[12][Size][Size];
	vector<vector<vector<double>>> imageAfterMean(12, vector<vector<double>>(Size + 4, vector<double>(Size + 4)));
	for (int i = 0; i < 12; i++) {
		double a = 0;
		for (int ii = 2; ii < Size+1; ii++) {
			for (int jj = 2; jj < Size+1; jj++) {
				double tempMean = 0;
				for (int iii = -2; iii < 3; iii++) {
					for (int jjj = -2; jjj < 3; jjj++) {
						tempMean += imagePadOut[i][ii + iii][jj + jjj];
					}
				}
				tempMean /= 25;
				imageAfterMean[i][ii][jj] = imagePadOut[i][ii][jj] - tempMean;
			}
		}
	}
	// total 25 filters
	int FilterIndex = 0;
	int Laws[9][5][5];
	for (int i = 0; i < 3; i++) {
		for (int j = 0; j < 3; j++) {
			for (int m = 0; m < 5; m++) {
				for (int n = 0; n < 5; n++) {
					Laws[FilterIndex][m][n] = Kernel[i][m] * Kernel[j][n];
				}
			}
			FilterIndex++;
		}
	}

	//int Filtered[12][NumF][Size][128];

	cout << "*";

	// for each image, filter 25 times

	// average energy
	double AverEnergy[12][9];
	for (int i = 0; i < 12; i++) {
		for (int j = 0; j < 9; j++) {
			// cout<<"*";
			double Aver = 0;
			for (int ii = 2; ii < Size + 1; ii++) {
				for (int jj = 2; jj < Size + 1; jj++) {
					double temp = 0;
					for (int fi = -2; fi < 3; fi++) {
						for (int fj = -2; fj < 3; fj++) {
							temp += imageAfterMean[i][ii + fi][jj + fj] * Laws[j][2 + fi][2 + fj];
						}
					}
					Aver += pow(temp, 2);
				}
			}
			AverEnergy[i][j] = Aver / pow(Size, 2);
		}
	}

	// // average energy
	// double AverEnergy[12][25];
	// for (int i = 0; i < 12; i++) {
	//   for (int j = 0; j < 25; j++) {
	//     int temp = 0;
	//
	//     AverEnergy[i][j] = temp/124/124;
	//   }
	// }


	// normalization of anergy
	double amean[1][9] = { 0,0,0,0,0,0,0,0,0};
	for (int i = 0; i < 12; i++) {
		for (int j = 0; j < 9; j++) {
			amean[0][j] += AverEnergy[i][j];
		}
	}
	for (int j = 0; j < 9; j++) {
		amean[0][j] = amean[0][j] / 12;
	}
	// standard deviation
	double standDev[1][9] = { 0,0,0,0,0,0,0,0,0 };
	for (int i = 0; i < 12; i++) {
		for (int j = 0; j < 9; j++) {
			standDev[0][j] += pow(AverEnergy[i][j] - amean[0][j], 2);
		}
	}
	for (int j = 0; j < 9; j++) {
		standDev[0][j] = sqrt(standDev[0][j] / 12);
	}

	// normalize
	for (int i = 0; i < 12; i++) {
		for (int j = 0; j < 9; j++) {
			AverEnergy[i][j] = (AverEnergy[i][j] - amean[0][j]) / standDev[0][j];
		}
	}

	for (int i = 0; i < 12; i++) {
		for (int j = 0; j < 9; j++) {
			cout << AverEnergy[i][j] << " ";
		}
		cout << endl;
	}
	for (int j = 0; j < 9; j++) {
		cout << standDev[0][j] << " ";
		cout << endl;
		cout << amean[0][j] << " ";
	}

	Mat data_pts(12, 9, CV_32F);
	for (int i = 0; i < 12; i++) {
		for (int j = 0; j < 9; j++) {
			data_pts.at<float>(i, j) = AverEnergy[i][j];
		}
	}

	PCA pca(data_pts, Mat(), PCA::DATA_AS_ROW, 3);
	Mat threeD;
	pca.project(data_pts, threeD);

	cout << "3D" << endl << threeD;

	TermCriteria criteria = TermCriteria(CV_TERMCRIT_EPS + CV_TERMCRIT_ITER, 50, 0.0001);
	int k = 4;
	int numberOfAttempts = 3;
	Mat labels, centers;

	// // // Apply K means:
	kmeans(data_pts, k, labels, criteria, numberOfAttempts, KMEANS_PP_CENTERS, centers);

	cout << "labels:   " << endl << labels;

	// for (int i = 0; i < 5; i++) {
	//   for (int j = 0; j < 5; j++) {
	//       cout<<Laws[0][i][j]<<" ";
	//   }
	//   cout<<endl;
	// }




	unsigned char test[Size + 4][Size + 4][1];
	for (int i = 0; i < Size + 4; i++) {
		for (int j = 0; j < Size + 4; j++) {
			test[i][j][0] = imagePadOut[0][i][j];
		}

	}

	// Write image data (filename specified by second argument) from image data matrix

	if (!(file = fopen(argv[13], "wb"))) {
		cout << "Cannot open file: " << argv[13] << endl;
		exit(1);
	}
	fwrite(test, sizeof(unsigned char), (Size + 4)*(Size + 4)*BytesPerPixel, file);
	fclose(file);

	// hold the command window
	string exitflag("\n");
	cout << "Try New Quit Processing. Start Test..." << endl;
	cout << "Press Q or q key to quit..." << endl;
	getline(cin, exitflag);
	while (exitflag.find('q') == string::npos && exitflag.find('Q') == string::npos)
	{
		cout << "Press Q or q key to quit..." << endl;
		getline(cin, exitflag);
	}


	return 0;
}


///////////////////////////////////////T E S T 1  E N D////////////////////////////////////////////////

*/





